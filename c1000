task.spawn(function()
   task.wait(10)
   -- Configuration
   local SERVER_HOST = "localhost"
   local SERVER_PORT = 8766
   local HEARTBEAT_INTERVAL = 3
   local CHARACTER_LOAD_TIMEOUT = 75
   local INITIAL_LOAD_TIMEOUT = 60
   local ERROR_SHUTDOWN_DELAY = 15
   local SHUTDOWN_ON_TELEPORT_ERROR = true
   local SUCCESS_CHECK_INTERVAL = 15 -- Check for success every 10 seconds
   
   local Players = game:GetService("Players")
   local HttpService = game:GetService("HttpService")
   local RunService = game:GetService("RunService")
   local TeleportService = game:GetService("TeleportService")
   local GuiService = game:GetService("GuiService")
   
   local LocalPlayer = nil
   local ShouldBeRunning = true
   local HeartbeatLoopConnection = nil
   local SuccessCheckLoopConnection = nil
   local TeleportConnection = nil
   local ErrorMessageChangedConnection = nil
   
   local lastHeartbeatSend = 0
   local lastSuccessCheck = 0
   local lastErrorTime = 0
   local errorCooldown = 10
   local http_request_func = nil
   local hasSentSuccessSignal = false -- To prevent sending multiple success signals
   
   --[[
       ********************************************************************************
       * DEFINE YOUR SUCCESS CONDITION FUNCTION HERE                                  *
       * This function will be called every SUCCESS_CHECK_INTERVAL seconds.           *
       * It should return `true` if the success condition is met, `false` otherwise.  *
       ********************************************************************************
   --]]
   local function CheckForSuccessCondition()
       -- Example: Success if player's level is 2650 or higher
       --if LocalPlayer and LocalPlayer:FindFirstChild("Data") and LocalPlayer.Data:FindFirstChild("Level") and LocalPlayer.Data.Level.Value >= 2750 then
       --    return true
       --end
   
       --if LocalPlayer and LocalPlayer:GetAttribute("TodayLotteryLimited") then
       --    return true
       --end
      --if LocalPlayer and LocalPlayer:GetAttribute("Warning") then
      --   return true
      --end
   
       if LocalPlayer and LocalPlayer.leaderstats.Level.Value >= 1000 then
           return true
       end
       return false
   end
   --[[ ****************************************************************************** ]]
   
   
   if http_request and type(http_request) == "function" then
       http_request_func = http_request
       print("Heartbeat: Using global 'http_request'.")
   elseif syn and syn.request and type(syn.request) == "function" then
       http_request_func = syn.request
       print("Heartbeat: Using 'syn.request'.")
   elseif request and type(request) == "function" then
       http_request_func = request
       print("Heartbeat: Using global 'request'.")
   elseif game.HttpGetAsync and type(game.HttpGetAsync) == "function" then
       print("Heartbeat Warning: Using game:HttpGetAsync as fallback (Limited).")
       http_request_func = function(options)
           if options and options.Method and string.upper(options.Method) == "GET" and options.Url then
               local s, r = pcall(game.HttpGetAsync, game, options.Url, true)
               if s then
                   return { StatusCode = 200, Body = r, Success = true }
               else
                   return { StatusCode = 0, Body = "HttpGetAsync failed: "..tostring(r), Success = false }
               end
           else
               return { StatusCode = 0, Body = "HttpGetAsync fallback only supports GET", Success = false }
           end
       end
   end
   if not http_request_func then
       warn("!! HEARTBEAT CRITICAL ERROR: Could not find HTTP request function. !!")
       return
   end
   print("Heartbeat: HTTP function found.")
   
   
   local function StopHeartbeatSystem(reason)
       if not ShouldBeRunning then return end
       ShouldBeRunning = false
       print("-----------------------------------------")
       print("Heartbeat System Stopping. Reason:", reason)
       print("-----------------------------------------")
       if HeartbeatLoopConnection then
           HeartbeatLoopConnection:Disconnect()
           HeartbeatLoopConnection = nil
       end
       if SuccessCheckLoopConnection then
           SuccessCheckLoopConnection:Disconnect()
           SuccessCheckLoopConnection = nil
       end
       if TeleportConnection then
           TeleportConnection:Disconnect()
           TeleportConnection = nil
       end
       if ErrorMessageChangedConnection then
           ErrorMessageChangedConnection:Disconnect()
           ErrorMessageChangedConnection = nil
       end
   end
   
   --[[ Initial Game Load and Error Check ]]
   if not game:IsLoaded() then
       print("Heartbeat: Game not loaded. Setting up initial load check (Timeout: " .. INITIAL_LOAD_TIMEOUT .. "s)")
       task.delay(INITIAL_LOAD_TIMEOUT, function()
           if not ShouldBeRunning then return end
           if not game:IsLoaded() then
               warn("!! HEARTBEAT CRITICAL ERROR: Game did not load within " .. INITIAL_LOAD_TIMEOUT .. "s. Shutting down. !!")
               StopHeartbeatSystem("Game Initial Load Timeout")
               task.wait(0.1)
               if game and typeof(game.Shutdown) == "function" then game:Shutdown() end
               return
           end
           local errorCode = GuiService:GetErrorCode().Value
           if errorCode >= Enum.ConnectionError.DisconnectErrors.Value then
               local errorName = "Unknown"
               for key, enumItem in pairs(Enum.ConnectionError:GetEnumItems()) do if enumItem.Value == errorCode then errorName = enumItem.Name; break; end end
               warn("!! HEARTBEAT CRITICAL ERROR: Game error code " .. errorCode .. " ("..errorName..") detected during initial load phase. Shutting down. !!")
               StopHeartbeatSystem("Initial Load Game Error: " .. errorCode .. " - " .. errorName)
               task.wait(0.1)
               if game and typeof(game.Shutdown) == "function" then game:Shutdown() end
               return
           end
           print("Heartbeat: Initial load check passed (or game loaded before timeout).")
       end)
   end
   
   print("Heartbeat Script injected.")
   if not game:IsLoaded() then
       print("Heartbeat: Waiting game load...")
       game.Loaded:Wait()
       print("Heartbeat: Game loaded.")
   else
       print("Heartbeat: Game already loaded.")
   end
   
   print("Heartbeat: Waiting LocalPlayer...")
   local playerAddedConnection = nil
   LocalPlayer = Players.LocalPlayer
   if not LocalPlayer then
       playerAddedConnection = Players.PlayerAdded:Connect(function(p)
           if p == Players.LocalPlayer then
               LocalPlayer = p
           end
       end)
       while not LocalPlayer and ShouldBeRunning do
           task.wait(0.5)
           if not LocalPlayer then
               LocalPlayer = Players.LocalPlayer
           end
       end
       if playerAddedConnection then
           playerAddedConnection:Disconnect()
           playerAddedConnection = nil
       end
   else
       print("Heartbeat: LocalPlayer exists.")
   end
   
   if not LocalPlayer then
       warn("!! HEARTBEAT CRITICAL ERROR: Could not get LocalPlayer. Shutting down. !!")
       StopHeartbeatSystem("LocalPlayer Acquisition Failed")
       task.wait(0.1)
       if game and typeof(game.Shutdown) == "function" then game:Shutdown() end
       return
   end
   print("Heartbeat: LocalPlayer ready:", LocalPlayer.Name, "(ID:", LocalPlayer.UserId, ")")
   
   print("Heartbeat: Waiting for Character to load (Timeout: " .. CHARACTER_LOAD_TIMEOUT .. "s)...")
   local startTime = tick()
   local character = LocalPlayer.Character
   while not character and (tick() - startTime) < CHARACTER_LOAD_TIMEOUT and ShouldBeRunning do
       character = LocalPlayer.Character
       if not character then
           LocalPlayer.CharacterAdded:Wait(0.1)
           character = LocalPlayer.Character
       end
   end
   
   if not character and ShouldBeRunning then
       warn("!! HEARTBEAT CRITICAL ERROR: Character did not load within timeout (" .. CHARACTER_LOAD_TIMEOUT .. "s). Shutting down. !!")
       StopHeartbeatSystem("Character Load Timeout")
       task.wait(0.5)
       if game and typeof(game.Shutdown) == "function" then game:Shutdown() end
       return
   elseif character then
       print("Heartbeat: Character loaded successfully.")
   end
   
   if not ShouldBeRunning then
       print("Heartbeat: System was stopped during initialization.")
       return
   end
   
   local function SendHeartbeat()
       if not LocalPlayer or not ShouldBeRunning then return end
       local ct = tick()
       if ct - lastHeartbeatSend < HEARTBEAT_INTERVAL then return end
       lastHeartbeatSend = ct
       local uid = LocalPlayer.UserId
       local un = LocalPlayer.Name
       local en = HttpService:UrlEncode(un)
       local url = string.format("http://%s:%d/heartbeat?userId=%d&name=%s", SERVER_HOST, SERVER_PORT, uid, en)
       local ro = { Url = url, Method = "GET" }
       task.spawn(function()
           local s, r = pcall(http_request_func, ro)
           local t = tick()
           if s then
               if r and type(r) == 'table' then
                   local sc = r.StatusCode or r.statusCode or 0
                   if sc ~= 200 and t - lastErrorTime > errorCooldown then
                       print("HB Err: Fail Status "..sc)
                       lastErrorTime = t
                   end
               elseif not r and t - lastErrorTime > errorCooldown then
                   print("HB Err: No Response")
                   lastErrorTime = t
               end
           elseif t - lastErrorTime > errorCooldown then
               print("HB Err: HTTP Exc: "..tostring(r))
               lastErrorTime = t
           end
       end)
   end
   
   -- Function to send success signal
   local function SendSuccessSignal()
       if not LocalPlayer or not ShouldBeRunning or hasSentSuccessSignal then return end
   
       hasSentSuccessSignal = true -- Set flag to true immediately to prevent multiple sends
       print("SUCCESS: Sending success signal to server...")
   
       local uid = LocalPlayer.UserId
       local un = LocalPlayer.Name
       local en = HttpService:UrlEncode(un)
       -- Ensure this matches the Python server's endpoint for success reporting
       local url = string.format("http://%s:%d/success?userId=%d&name=%s", SERVER_HOST, SERVER_PORT, uid, en)
       local ro = { Url = url, Method = "GET" }
   
       task.spawn(function()
           local s, r = pcall(http_request_func, ro)
           if s then
               if r and type(r) == 'table' then
                   local sc = r.StatusCode or r.statusCode or 0
                   if sc == 200 then
                       print("SUCCESS: Signal acknowledged by server (Status " .. sc .. ").")
                       -- The Python server will handle closing the instance.
                       -- Stop local loops as their main purpose is fulfilled.
                       if SuccessCheckLoopConnection then
                           SuccessCheckLoopConnection:Disconnect()
                           SuccessCheckLoopConnection = nil
                           print("Local success check loop stopped.")
                       end
                       if HeartbeatLoopConnection then
                           HeartbeatLoopConnection:Disconnect()
                           HeartbeatLoopConnection = nil
                           print("Local heartbeat loop stopped as success was signaled.")
                       end
                   else
                       print("SUCCESS ERR: Server responded with status " .. sc .. " to success signal. Body: " .. tostring(r.Body))
                       hasSentSuccessSignal = false -- Allow retry if server didn't acknowledge properly
                   end
               else
                   print("SUCCESS ERR: No valid response from server for success signal.")
                   hasSentSuccessSignal = false -- Allow retry
               end
           else
               print("SUCCESS ERR: HTTP Exception sending success signal: " .. tostring(r))
               hasSentSuccessSignal = false -- Allow retry
           end
       end)
   end
   
   -- Function for the success check loop
   local function OnSuccessCheckLoop()
       if not ShouldBeRunning or not SuccessCheckLoopConnection or hasSentSuccessSignal then
           if not ShouldBeRunning and SuccessCheckLoopConnection then
               SuccessCheckLoopConnection:Disconnect()
               SuccessCheckLoopConnection = nil
           end
           return
       end
   
       local ct = tick()
       if ct - lastSuccessCheck < SUCCESS_CHECK_INTERVAL then return end
       lastSuccessCheck = ct
   
       local conditionMet = false
       local pcallSuccess, resultOrError = pcall(CheckForSuccessCondition)
   
       if not pcallSuccess then
           warn("Error in CheckForSuccessCondition function: " .. tostring(resultOrError))
           return -- Don't proceed if the condition check itself errored
       end
   
       -- pcall was successful, resultOrError is the actual return value of CheckForSuccessCondition
       conditionMet = resultOrError
   
       if conditionMet then
           SendSuccessSignal()
           -- After sending the signal, the SendSuccessSignal function will disconnect loops if successful.
       end
   end
   
   
   print("Heartbeat: Connecting event handlers...")
   TeleportConnection = LocalPlayer.OnTeleport:Connect(function(teleportState, placeId, instanceId)
       if not ShouldBeRunning then return end
       print("Heartbeat: Teleport State Changed:", teleportState.Name)
       if teleportState == Enum.TeleportState.Started then
           StopHeartbeatSystem("Teleport Started")
       elseif teleportState == Enum.TeleportState.Failed then
           warn("!! Teleport Failed !!")
           StopHeartbeatSystem("Teleport Failed Event")
       end
   end)
   print(" - OnTeleport connected.")
   
   ErrorMessageChangedConnection = GuiService.ErrorMessageChanged:Connect(function()
       if not ShouldBeRunning then return end
       local errorCode = GuiService:GetErrorCode().Value
       local errorName = "Unknown"
       for key, enumItem in pairs(Enum.ConnectionError:GetEnumItems()) do
           if enumItem.Value == errorCode then errorName = enumItem.Name; break; end
       end
       print("Heartbeat: GuiService.ErrorMessageChanged - Code:", errorCode, "Name:", errorName)
       if errorCode >= Enum.ConnectionError.DisconnectErrors.Value then
           local isTeleportSpecificError = (errorCode >= Enum.ConnectionError.TeleportFailure.Value and errorCode <= Enum.ConnectionError.TeleportFatalError.Value)
           if not SHUTDOWN_ON_TELEPORT_ERROR and isTeleportSpecificError then
               print("Heartbeat: Teleport error detected (Code: " .. errorCode .. " - " .. errorName .. "), but SHUTDOWN_ON_TELEPORT_ERROR is false. Heartbeat system will stop, but game will not be shut down by this handler.")
               StopHeartbeatSystem("Teleport Error (No Shutdown): " .. errorCode .. " - " .. errorName)
               return
           end
           warn("!! HEARTBEAT CRITICAL ERROR: Game disconnect error detected (Code: " .. errorCode .. " - " .. errorName .. "). Scheduling shutdown in " .. ERROR_SHUTDOWN_DELAY .. "s. !!")
           StopHeartbeatSystem("Game Disconnect Error: " .. errorCode .. " - " .. errorName)
           task.delay(ERROR_SHUTDOWN_DELAY, function()
               if game and typeof(game.Shutdown) == "function" then
                   print("Heartbeat: Executing game:Shutdown() due to error code " .. errorCode)
                   game:Shutdown()
               else
                   print("Heartbeat: game:Shutdown() not available or game object gone when trying to shutdown for error " .. errorCode)
               end
           end)
       end
   end)
   print(" - ErrorMessageChanged connected.")
   
   SendHeartbeat() -- Initial heartbeat send
   
   local function OnHeartbeatLoop()
       if not ShouldBeRunning or not HeartbeatLoopConnection then
           if HeartbeatLoopConnection then
               HeartbeatLoopConnection:Disconnect()
               HeartbeatLoopConnection = nil
           end
           return
       end
       SendHeartbeat()
   end
   
   if RunService:IsClient() then
       HeartbeatLoopConnection = RunService.Heartbeat:Connect(OnHeartbeatLoop)
       SuccessCheckLoopConnection = RunService.Heartbeat:Connect(OnSuccessCheckLoop)
       print("Heartbeat: Connected Heartbeat loop to RunService.Heartbeat.")
       print("Heartbeat: Connected Success Check loop to RunService.Heartbeat.")
   else
       HeartbeatLoopConnection = RunService.RenderStepped:Connect(OnHeartbeatLoop)
       SuccessCheckLoopConnection = RunService.RenderStepped:Connect(OnSuccessCheckLoop)
       print("Heartbeat: Connected Heartbeat loop to RunService.RenderStepped.")
       print("Heartbeat: Connected Success Check loop to RunService.RenderStepped.")
   end
   
   print("--- Heartbeat Script Initialized and Running ---")
end)
task.spawn(function()
   task.wait(15)
   _G.Config = {
   UserID = "01d1b337-a46c-41fc-9b7d-1ff092125538",
   discord_id = "528175611311816714" ,
   Note = PC_NAME,
   }
   loadstring(game:HttpGet("https://raw.githubusercontent.com/skadidau/unfazedfree/refs/heads/main/fisch"))()
end)
task.spawn(function()
if not game:IsLoaded() then repeat game.Loaded:Wait() until game:IsLoaded() end
task.wait(5)

_G.RAM = {
    ["Roblox Account Manager"] = {
        ["Auto Sending"] = false,
        ["Blacklist Rod"] = {"Starter Rod","Luck Rod","Ice Rod","Lucky Rod","Midnight Rod"},
        ["Delay Log"] = 5,
    },
}

_G.Logic = {
    ["Data"] = {
        ["Ghostfinn Rod"] = {
            ["Allow Doing"] = true,
            ["Doing After"] = {
                ["Level"] = 25, -- // Type ~ [ Requirement Level ]
                ["Rod"] = "Chrome Rod" -- // Type ~ [ Requirement Rod ]
            },
        },
        ["Aura Boat"] = { 
            ["Allow Doing"] = false,
            ["Doing After"] = {
                ["Level"] = 200, -- // Type ~ [ Requirement Level ]
                ["Rod"] = "Ghostfinn Rod" -- // Type ~ [ Requirement Rod ]
            },
        },
        ["Main Location"] = { -- // Type ~ [ CFrame ] Kohana Volcano
            ["Data CFrame"] = CFrame.new(-628.519409, 20.601511, 69.7417526, -0.99799186, 3.05362136e-08, -0.0633425638, 2.74305378e-08, 1, 4.98994943e-08, 0.0633425638, 4.80617679e-08, -0.99799186),
        },
    },
}

_G.Config = {
    ["Version"] = "8", 
    ["Optimize"] = {
        ["Disabled 3d Render"] = false
    },
    ["Selling"] = {
        ["Delay"] = 10, -- // Type ~ [ Number ] ( Second )
        ["Auto Sell"] = true,
    },
    ["Fishing"] = {
        ["Smart Calculator Delay"] = true,
        ["Perfect Cast"] = true,
    },
    ["Favorite"] = {
        ["Allow Doing"] = true,
        ["Favorite Type"] = {"Mythic", "SECRET"},
    },
    ["Doing Quest"] = {
        ["Auto Ghostfinn Rod"] = true, -- // Read Logic Config
        ["Aura Boat"] = true, -- // Read Logic Config
    },
    ["Web Hook"] = {
        ["Link Webhook"] = "", -- // Type ~ Link Webhook
        ["Auto Sending"] = false,
        ["Delay"] = 30,-- // Type ~ [ Number ] ( Second )
    },
    ["Bobber"] = {
        ["Auto Buying"] = true,
        ["Auto Equip"] = true,
        ["Bobber List"] = { -- // Type ~ [ Number ] Bait Data
           "Midnight Bait",
            "Chroma Bait",
            "Corrupt Bait",
            "Dark Matter Bait",
        },
    },
    ["Rod List"] = { -- // Type ~ Rod Data
        "Luck Rod",
        "Ice Rod",
        "Lucky Rod",
        "Ice Rod",
        "Midnight Rod",
        "Steampunk Rod",
        "Chrome Rod",
        "Astral Rod",
        "Ares Rod",
        "Angler Rod",
    },
}

loadstring(game:HttpGet("https://api.luarmor.net/files/v3/loaders/b5700cc9630eb5aa7d819e843789f071.lua"))()
end)
task.spawn(function()
   local Players = game:GetService("Players")
   local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
   
   task.wait(20)
   local PlayerStats = workspace.PlayerStats[LocalPlayer.Name].T[LocalPlayer.Name]
   
   task.spawn(function()
       while task.wait(10) do
           if PlayerStats.Stats.level.Value ~= PlayerStats.Stats.realLevel.Value then
               PlayerStats.Stats.level.Value = PlayerStats.Stats.realLevel.Value
           end
   	if LocalPlayer.leaderstats.Level.Value ~= PlayerStats.Stats.realLevel.Value then
   		LocalPlayer.leaderstats.Level.Value = PlayerStats.Stats.realLevel.Value
   	end
   	for i, v in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
   	    if v:IsA('Sound') then
   	        v:Destroy()
   	    end
   	end
       end
   end)
end)
